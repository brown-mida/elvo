"""
Purpose: Manually analyze the false negative cases generated by our current
best Resnet-50 model. Images are generate using the same code as
multichannel_mip.py.
"""

import logging
from matplotlib import pyplot as plt
import cloud_management as cloud
import transforms

# list of current false negatives, as taken from failure analysis spreadsheet
FAILURE_ANALYSIS = ['SSQSB70QYC5L5CJJ',
                    'MTWW42SPCGLHEDKY',
                    'GKDV3FW4M56I3IKV',
                    'BMFSUHVBPJ7RY56P',
                    'NWO33W453F6ZJ4BU',
                    'NWO33W453F6ZJ4BU',
                    '8TLM2DUBYEE2GDH0',
                    'J3JHPC3E15NZGX34',
                    'J3JHPC3E15NZGX35',
                    '3AWM4ZZHCWJ8MREY',
                    'MHL54TPCTOQJ2I4K',
                    '5H94IH9XGI83T610',
                    'UGXVSPJLHJL6AHSW',
                    '2KMKXR2G1BLD0C2G',
                    '2KMKXR2G1BLD0C2G',
                    'PCNMFAZL5VWWK7RP',
                    'VVGO45TQNOASBLZM',
                    'NHXCOHZ4HH53NLQ6',
                    'F8W2RDY3D6L2EOFT',
                    'KK2Y9XHUUUC5LISA',
                    'HZLBHRHYLSY9TXJ4',
                    '0RB9KGMO90G1YQZD',
                    '0RB9KGMO90G1YQZD',
                    'J2JPFK8ZOICHFG34',
                    'HLXOSVDF27JWNCMJ',
                    'AEPRN5R7W2ASOGR0',
                    '99YJX0CY4FHHW46S',
                    'LOZOKQFJMDLL6IL5',
                    'STCSWQHX4UN23CDK',
                    'ZC9H37RWIQ90483S',
                    'CJDXGZHXAGH7QL3C',
                    '5KZSOKNYS84ZTDK6',
                    'AKZ8T688ZRU9UTY2',
                    '6BMRRS9RAZUPR3IL',
                    'HXLMZWH3SFX3SPAN',
                    'GHVG2CNNRZ65UBEU',
                    'TSDXCC6X3M7PG91E',
                    'TSDXCC6X3M7PG91E',
                    'IP4X9W512RO56NQ7',
                    'LNU3P20QOML7YGMZ',
                    '56GX2GI8AGT0BIHN',
                    'TSZFE43KG3NQJR69',
                    'IXRSXXZI0S6L0EJI',
                    'FCYGZ75WMW6L4PJM',
                    'KOE9CU24WK2TUQ43',
                    'KOE9CU24WK2TUQ44',
                    'TFIG39JA77W6USD3',
                    'XQBRGW3CYGNUMWHI',
                    'PB7YJZRJU74HFKTS',
                    'EUNTRXNEDB7VDVIS',
                    'JQWIIAADGKE2YMJS',
                    'NXLFQLVZRLUEK2UF',
                    'NXLFQLVZRLUEK2UF',
                    'RHWTMTHC7HIWZ2YZ',
                    'RW13S0OR03CO7OP5',
                    'LYUO2OPTNYUBCHT2',
                    'CSCIKXOMNAIB3LUQ',
                    'Q8BNE59JIKQLLYJ1',
                    'K2GS9PIQ1E0DBDBE',
                    'WWEFFBIMLZ3KLQVZ']

WHENCE = ['numpy']


def configure_logger():
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    root_logger.addHandler(handler)


if __name__ == '__main__':
    configure_logger()
    client = cloud.authenticate()
    bucket = client.get_bucket('elvos')

    # iterate through every source directory...
    for location in WHENCE:
        prefix = location + '/'
        logging.info(f"MIPing images from {prefix}")

        for in_blob in bucket.list_blobs(prefix=prefix):
            # blacklist
            if in_blob.name == prefix + 'LAUIHISOEZIM5ILF.npy':
                continue

            # if in_blob.name != prefix + 'HID1X1SOO57L1A87.npy':
            #     continue

            if in_blob.name not in list(map(lambda i: prefix + i + '.npy',
                                            FAILURE_ANALYSIS)):
                continue

            # perform the normal MIPing procedure
            logging.info(f'downloading {in_blob.name}')
            input_arr = cloud.download_array(in_blob)
            logging.info(f"blob shape: {input_arr.shape}")
            cropped_arr = transforms.crop_multichannel(input_arr, location)
            not_extreme_arr = transforms.remove_extremes(cropped_arr)
            logging.info(f'removed array extremes')
            mip_arr = transforms.mip_multichannel(not_extreme_arr)
            for i in range(3):
                plt.figure(figsize=(6, 6))
                plt.imshow(mip_arr[i], interpolation='none')
                plt.show()
